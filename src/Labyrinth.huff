/// @title Labyrinth
/// @author https://github.com/kadenzipfel
/// @dev lost?

/// ╦  ╔═╗╔╗ ╦ ╦╦═╗╦╔╗╔╔╦╗╦ ╦
/// ║  ╠═╣╠╩╗╚╦╝╠╦╝║║║║ ║ ╠═╣
/// ╩═╝╩ ╩╚═╝ ╩ ╩╚═╩╝╚╝ ╩ ╩ ╩

/// @notice Returns the puzzle's name.
#define function name() view returns (string memory)
/// @notice Generates the puzzle's starting position based on a seed.
#define function generate(address _seed) view returns (uint256)
/// @notice Verifies that a solution is valid for the puzzle.
#define function verify(uint256 _start, uint256 _solution) nonpayable returns (bool)

#define macro NAME() = takes (0) returns (0) {
    0x20 push0 mstore           // []
    0x4c61627972696e7468        // ["Labyrinth"]
    0x29 mstore                 // []
    0x09 0x20 mstore            // []
    0x60 push0 return           // []
}

#define macro GENERATE() = takes (0) returns (0) {
    0x04 calldataload           // [_seed]
    push0 mstore                // []
    number 0x20 mstore          // []
    0x40 push0 sha3             // [_start]
    push0 mstore                // []
    0x20 push0 return           // []
}

#define macro VERIFY() = takes (0) returns (0) {
    0x04 calldataload           // [_start]
    0x24 calldataload           // [_solution, _start]

    push0 push0                 // [i, pos, _solution, _start]
    loop:
        dup3 dup2               // [i, _solution, i, pos, _solution, _start]
        0x02 mul                // [i * 2, _solution, i, pos, _solution, _start]
        shr 0x03 and            // [dir, i, pos, _solution, _start]

        dup1 iszero             // [dir == 0, dir, i, pos, _solution, _start]
        up jumpi                // [dir, i, pos, _solution, _start]

        dup1 0x01 eq            // [dir == 1, dir, i, pos, _solution, _start]
        right jumpi             // [dir, i, pos, _solution, _start]

        dup1 0x02 eq            // [dir == 2, dir, i, pos, _solution, _start]
        left jumpi              // [dir, i, pos, _solution, _start]

        dup1 0x03 eq            // [dir == 3, dir, i, pos, _solution, _start]
        down jumpi              // [dir, i, pos, _solution, _start]

        up:
            0x10 dup2 sub       // [pos - 0x10, dir, i, pos, _solution, _start]
            dup1 swap4 lt       // [boundary?, dir, i, pos, _solution, _start]
            exit jumpi          // [dir, i, pos, _solution, _start]
            check jump          // [dir, i, pos, _solution, _start]

        right:
            0x10 dup4 0x01      // [1, pos, 0x10, dir, i, pos, _solution, _start]
            addmod iszero       // [boundary?, dir, i, pos, _solution, _start]
            exit jumpi          // [dir, i, pos, _solution, _start]

            swap2 0x01 add      // [pos + 1, i, dir, _solution, _start]
            swap2               // [dir, i, pos, _solution, _start]
            check jump          // [dir, i, pos, _solution, _start]

        left:
            0x10 dup4 mod       // [pos % 0x10, dir, i, pos, _solution, _start]
            iszero              // [boundary?, dir, i, pos, _solution, _start]
            exit jumpi          // [dir, i, pos, _solution, _start]

            swap2 0x01 sub      // [pos - 1, i, dir, _solution, _start]
            swap2               // [dir, i, pos, _solution, _start]
            check jump          // [dir, i, pos, _solution, _start]

        down:
            swap2 0x10 add      // [pos + 0x10, i, dir, _solution, _start]
            dup1 0xff lt        // [boundary?, pos, i, dir, _solution, _start]
            exit jumpi          // [pos, i, dir, _solution, _start]
            swap2               // [dir, i, pos, _solution, _start]
            check jump          // [dir, i, pos, _solution, _start]

        check:
            dup5 dup4 shr       // [_start >> pos, dir, i, pos, _solution, _start]
            0x01 and            // [_start >> pos & 1, dir, i, pos, _solution, _start]
            iszero iszero       // [wall?, dir, i, pos, _solution, _start]
            exit jumpi          // [dir, i, pos, _solution, _start]

            dup2 0xff eq        // [finish?, dir, i, pos, _solution, _start]
            success jumpi       // [dir, i, pos, _solution, _start]

        loop jump

    exit: 
        0x20 push0 return

    success:
        0x01 push0 mstore
        0x20 push0 return
}

#define macro MAIN() = takes (0) returns (0) {
    push0 calldataload 0xe0 shr
    dup1 0x06fdde03 eq name jumpi
    dup1 0x2fa61cd8 eq generate jumpi
    dup1 0x41161b10 eq verify jumpi

    push0 push0 revert

    name: 
        NAME()
    generate: 
        GENERATE()
    verify: 
        VERIFY()
}