/// @title Labyrinth
/// @author https://github.com/kadenzipfel
/// @dev lost?

/// ╦  ╔═╗╔╗ ╦ ╦╦═╗╦╔╗╔╔╦╗╦ ╦
/// ║  ╠═╣╠╩╗╚╦╝╠╦╝║║║║ ║ ╠═╣
/// ╩═╝╩ ╩╚═╝ ╩ ╩╚═╩╝╚╝ ╩ ╩ ╩

/// @notice Returns the puzzle's name.
#define function name() view returns (string memory)
/// @notice Generates the puzzle's starting position based on a seed.
#define function generate(address _seed) view returns (uint256)
/// @notice Verifies that a solution is valid for the puzzle.
#define function verify(uint256 _start, uint256 _solution) nonpayable returns (bool)

#define macro NAME() = takes (0) returns (0) {
    0x20 push0 mstore           
    0x4c61627972696e7468        
    0x29 mstore                 
    0x09 0x20 mstore            
    0x60 push0 return           
}

#define macro GENERATE() = takes (0) returns (0) {
    0x04 calldataload           
    push0 mstore                
    number 0x20 mstore          
    0x40 push0 sha3             
    push0 mstore                
    0x20 push0 return           
}

#define macro VERIFY() = takes (0) returns (0) {
    0x04 calldataload           
    0x24 calldataload           

    push0 push0                 
    loop:
        dup3 dup2               
        0x02 mul                
        shr 0x03 and            

        dup1 iszero             
        up jumpi                

        dup1 0x01 eq            
        right jumpi             

        dup1 0x02 eq            
        left jumpi              

        dup1 0x03 eq            
        down jumpi              

        up:
            0x10 dup2 sub       
            dup1 swap4 lt       
            exit jumpi          
            check jump          

        right:
            0x10 dup4 0x01      
            addmod iszero       
            exit jumpi          

            swap2 0x01 add      
            swap2               
            check jump          

        left:
            0x10 dup4 mod       
            iszero              
            exit jumpi          

            swap2 0x01 sub      
            swap2               
            check jump          

        down:
            swap2 0x10 add      
            dup1 0xff lt        
            exit jumpi          
            swap2               
            check jump          

        check:
            dup5 dup4 shr       
            0x01 and            
            exit jumpi          

            dup3 0xff eq        
            success jumpi       

            swap1 0x01 add      
            swap1 pop           

        loop jump

    exit: 
        0x20 push0 return

    success:
        0x01 push0 mstore
        0x20 push0 return
}

#define macro MAIN() = takes (0) returns (0) {
    push0 calldataload 0xe0 shr
    dup1 0x06fdde03 eq name jumpi
    dup1 0x2fa61cd8 eq generate jumpi
    dup1 0x41161b10 eq verify jumpi

    push0 push0 revert

    name: 
        NAME()
    generate: 
        GENERATE()
    verify: 
        VERIFY()
}